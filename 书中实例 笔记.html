<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript">
//        Ctrl + F 当前代码（文件）中查找
//        <!--Ctrl + N 查找类-->
//        <!--Ctrl + R 替换-->
//        <!--Ctrl + Alt + L 格式化代码-->
//        <!--Ctrl + Y 删除行-->
//        <!--ctrl + X 剪切行-->
//        <!--Ctrl + J 自动代码提示-->
//        <!--Ctrl + D 复制行或是块-->
//        <!--Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示。-->
//        <!--Ctrl + Shift 光标放在image上可查看图片-->
//        <!--Ctrl + Shift + F 查找整个项目相关关键字文件（非常非常常用）（通过某个词，指定要搜索的文件类型，目录（跟myeclipse中的ctrl+H功能一样））-->
//        <!--Ctrl + Shift + N通过文件名查找指定文件（非常非常常用）-->




        //在script代码中不能出现<\/script>需要使用转义符“\”
        alert("<\/script>");

//  *************************************      第十章 DOM        ****************************************************

//        文档元素<html>,是文档节点的唯一子节点，文档节点是所有节点的根节点。


//**********************************   Node类型


/*        Node.ELEMENT_NODE(1);   node.Type==1 元素节点
          Node.ATTRIBUTE_NODE(2);
          Node.TEXT_NODE(3);        node.Type==3 文本节点
          Node.DOCUMENT_NODE(9);    node.Type==9  document节点
 */

        if(somenode.nodeType==1){                  //使用if语句判断一个节点是否是元素节点
            alert("Node is an element");
        }

//        每个节点都有childNodes属性，其中保存着一个NodeList对象。NodeList是一个类数组对象，并不是一个Array的实例。有length属性,
//        且变化可以自动反映在NodeList中。hasChildNodes()方法可以判断是否还有子元素。

        var firstChild=somenode.childNodes[0];
        var secondChild=somenode.childNodes.item(1);   //使用item方法和方括号[]方法都可。
        var count=somenode.childNodes.length;


//       如何将一个NodeList对象转化成数组呢？
        function converToArray(nodes) {                     //参数nodes为一个NodeList对象
            var array=null;
            try{
                array=Array.prototype.slice().call(nodes,0);  //IE8之前版本的浏览器无效
            }
            catch(ex){
                array=new Array();
                for(var i=0;i<nodes.length;i++){
                    array.push(nodes[i]);                       //遍历nodes对象，将每个元素推入数组array中。
                }
            }
        }


//      我们也可以对节点进行操作，方法一：appendChild()，向childNodes列表的末尾添加一个节点。如果是文本中存在的节点，那么就移动到新位置
         var returnedNode=somenode.appendChild(newNode);
         alert(returnedNode==newNode);          //true  appendChild()方法返回值是新增的节点。
         alert(returnedNode==somenode.lastChild);    //true

//      方法二：insertBefore()， 参数一要插入的节点,参数二作为参照的节点 ，插入在参照节点之前。返回值是被插入的节点
        //插入成为最后一个子节点
        var returnNode=somenode.insertBefore(newnode,null);
        alert(returnNode==somenode.lastChild);  //true

        //插入成为第一个子节点
        var returnNode=somenode.insertBefore(newNode,somenode.firstChild);

        //在最后一个子节点之前插入
        var returnNode=somenode.insertBefore(newNode,somenode.lastChild);
        alert(returnNode==somenode.childNodes[somenode.childNodes.length-2]); //true

//     方法三：replaceChild(),两个参数：要插入的节点和要替换的节点，该方法返回值是被替换的节点。
//     方法四：removeChild(),一个参数：要移除的节点，该方法返回值是移除的节点。
//     方法三和方法四中被替换和被移除的节点仍然存在于文本中，只是没有了自己的位置。

//     方法五：cloneNode(),接受一个布尔值参数，true时执行深复制，复制节点和整个子节点树；false时只复制节点的本身。
//            注意：复制后的文本并不存在于文档中，需要使用上述的方法将其添加到文档中。


//********************************************* document类型 ************************************************************
    //     第一个子元素为<html>  Node.DOCUMENT_NODE(9);    node.Type==9  document节点

         var  html=document.documentElement;  //取得对html的引用
         var  body=document.body;              //取得对body的引用
         var  url=document.URL;                  //取得完整的URL
         var domain=document.domain;                //取得域名
    /*
        查找元素 document.getElementById() 和 document.getElementsByTagName()
        document.getElementById()  中的id参数，需要完全匹配元素中的id属性，包括大小写。
        document.getElementsByTagName() 以标签名为参数 ，返回一个包含零或者多个元素的NodeList（和childNodes属性返回的类似），
        这里称之为HTMLCollection对象*/

        var item=document.getElementById();                 //返回匹配的那个元素
        var images=document.getElementsByTagName("img");    //images为HTMLCollection对象
        alert(images.length);   //输出图像的数量
        alert(images[0].src);
        alert(images.item(0).src) ;    //输出第一个元素的src

//      HTMLCollection对象有一个namedItem()的方法，可以通过元素的name特性来取得其中的项。

        var myImages=images.namedItem("myimages");            // name="myimages"的项

//      方法三：getElementByName()  获取特定name属性的元素，最常用于取得单选按钮

 //     特殊的集合    HTMLCollection对象
        var anchors=document.anchors;    //文档中带name属性的a元素
        var forms=document.forms;      //文档中所有的form元素，于getElementsByTagName("form")相同。
        var link=document.links;       //文档中带href属性的a元素
        var image=document.images;

//      文档写入：write(),writeln(),open(),close()。如果在文档加载完成后调用write()会重写整个页面
        document.write("<storng>"+(new Data()).toString()+"</strong>");   // 按原样写入

        document.writeln();                                      //会换行

//********************************************   Element类型   *********************************************************

//      Node.ELEMENT_NODE(1);   node.Type==1 元素节点    NodeName标签名，nodeValue=null
        alert(element.nodeName==element.tagName);  //true

//      元素的nodeName属性==元素的tagName属性
//      在Html和XMl中属性获得的标签名的大小写会不同 因此最好增加判断：
        if(element.tagName.toLowerCase()=="div"){
            // 执行操作
        }

//      元素的标准特性：id, className(元素的类名，不用class是因为class是保留字),title,lang ,dir
        alert(element.id);   //取得元素的id; 其他类同。

//      也可使用getAttribute() 获取特性，但一般在获取自定义的特性(除了标准特性，也可自己定义特性)时使用。
        alert(element.getAttribute("id")); // 取得元素的id;

//        有2类特性，在使用getAttribute()获取时和使用属性获取时会出现不同，一类是style特性，一类是onclick这类事件程序。

        //使用赋值为元素添加的自定义的属性，不会自动变成元素的特性(默认属性可以)
        div.color="red";
        alert(element.getAttribute("color"));//null

        element.setAttribute("id","someOtherId"); //设置id的值为someOtherId，如果不存在就创建，如果存在就替换。

        element.removeAttribute("id");      //不仅删除值，也将特性删除

//      attributes属性返回一个NamedNodeMap对象，与NodeList类似，如果需要将一个元素中的所有特性都转化成为输出的字符串时，用
//        这个特性会比较方便，直接使用for循环将每个特性都依次输出
        alert(element.attributes.length);  //特性的个数
        alert(element.attributes[0].nodename);   //获取特性的名称
        alert(element.attributes[0].nodeValue);     //获取特性的值


//      创建一个元素
        var div=document.createElement("div");

        div.id="myId";          //添加特性

        document.body.appendChild(div); //将元素添加到body中 也可以使用document.getElementById()来获取元素，并添加到该元素末尾。

//      在IE中，可以使用另一种方法创建一个元素。 有助于避开在ie7中的一些问题。

        var div1=document.createElement("<div id=\'myNewDiv\' class=\'box\'>内容</div>");

 //     元素的子节点
/*    <ul id="mylist">
        <li>item1</li>
        <li>item1</li>
        <li>item1</li>
      </ul>*/

//      在IE中，上面的节点会有3个子元素<li>,在其他现代浏览器中有7个子元素，3个<li>加上4个空白节点。如需要遍历子节点需要判断：
        if(element.childNodes[i].nodeType==1)
        {
            //执行代码
        }
        //不仅document支持getElementByTagName，元素也支持：
        var ul=document.getElementById("mylist");
        var items=ul.getElementsByTagName("li");


//****************************************************** Text类型********************************************************
//      nodeType=3 parentNode 是一个元素  nodeValue为节点所包含的文本   没有子节点

//        可以通过nodeValue属性和data属性访问Text节点中的文本
        alert(element.firstChild.nodeValue);   // 获取文本节点中的文本
        element.firstChild.appendData(text);  //将text添加到节点的末尾
        element.firstChild.deleteData(offset,count); //从offset指定的位置开始删除count个字符
        element.firstChild.insertData(offset,text);   //从offset指定的位置插入text;
        element.firstChild.replaceData(offset,count,text);  //用text代替从offset开始到offset+count处的文本
        element.firstChild.splitText(offset);       //从offset指定的位置将文本节点分成2个文本节点 返回后面的文本节点
        element.firstChild.substringData(offset,count); //提取从offset指定位置到offset+count处的字符串 返回提取出的字符串

      //创建元素节点，文本节点； 并添加文本节点到元素节点中 ；最后添加到文档中
        var elementNode=document.createElement("div");
        elementNode.className="message";
        var textNode=document.createTextNode("<strong>hello</strong> world!");
        elementNode.appendChild(textNode);
        document.body.appendChild(elementNode);


        //规范化文本节点
        element.normalize();
        //如果元素element中有多个文本节点，调用该方法是可以将多个文本节点合并成一个


    //Comment类型：
    //DocumentFragment类型：

        //可以在里面保存要添加到文档的节点，是一个文档片段。文档片段本身不会添加到文档中，只会将其所有的子节点添加。
        var fragment=document.createDocumentFragment();//创建了一个文档片段
        var ul=document.getElementById("mylist");
        for(var i=0;i<3;i++){                           //在fragment中添加3个li子节点
            var li=document.createElement("li");
            li.appendChild(element.createTextNode("Item"+(i+1)));
            fragment.appendChild(li);
        }
        ul.appendChild(fragment);                       //把3个子节点一次性添加到ul中




    //DOM操作:
        //操作script 操作CSS，原理很简单，就是动态添加一个元素，只是一个是<script>,一个是<style>,需要注意的是，最后style需要添加
            //到head中去，不能添加在body中。IE中使用appendChild添加文本节点是会报错，它视script和style的子节点为特殊的节点，不允许访问，              所以可以使用script.text=... 和style.styleSheet.cssText=.. 来添加文本节点。


    //操作表格:

        /*
        * tbody:表格体
        * rows：一个表格所以行的HTMLCollection 是一个集合，可以使用rows[0]访问
        * cells:保存tr元素中单元格的HTMLCollection
        * insertRow()：指定位置插入一行
        * deleteRow()：指定位置删除一行
        * insertcell()：指定位置插入一个单元格
        * deletecell():指定位置删除一个单元格*/

        var table=document.getElementById("tb");    //获取一个表格元素
        table.border=1;
        table.width=100%;
        var tbody=table.createElement("tbody");               //添加一个tbody
        table.appendChild(tbody);                               //tbody添加到table中
        tbody.insertRow(0);                                     //插入一行
        tbody.insertRow(0).insertCell(0);                       //插入第一行第一列
        tbody.insertRow(0).insertCell(0).appendChild(document.createTextNode("Cell,1,1"));//插入内容
        tbody.insertRow(0).insertCell(1);
        tbody.insertRow(0).insertCell(1).appendChild(document.createTextNode("Cell,1,1"));
        //以此类推

//****************************************DOM扩展*****************************************************************
    //选择符API
        //1.querySelector()方法：返回与CSS选择符匹配的第一个元素。
            //通过document调用 ，在文档中查找。
            var body=document.querySelector("body");    //元素选择
            var myDiv=document.querySelector("#myDiv"); //ID选择
            var selected=document.querySelector(".select"); //取得类为select的第一个元素

            //如果通过元素调用，那么会在元素的后代中查找。


        //2.querySelectorAll():接受的选择符与querySelector的相同，返回的是一个nodeList的集合。类似childNodes。document,                          documentFragment,Element 都可以调用。
            var ems=document.getElementById("myDiv").querySelectorAll("em");    //取得myDiv中的所有的em元素并返回。
            var emsFirst=ems[0];    //取得第一个em元素，ems.item(0)也可。


    //元素的遍历：
        //之前提到过，在获取元素的时候，会将元素之间的空白节点也作为一个子元素，这样就需要增加一个判断是否是元素。现在，添加了一组新的规           范，可以直接获得后代中的元素而忽略空格
            /*
            * childElementCount：返回子元素的个数
            * firstElementChild:第一个子元素
            * lastElementChild：最后一个子元素
            * previousElementSibling：同辈前一个子元素
            * nextElementSibling：同辈下一个子元素*/

            var child=element.firstElementChild;        //第一个子元素

    //与类相关的扩充：

        //1.getElementByClassName():doucument，Element都可以使用这个方法。接受一个参数，包含一个或者多个类。返回带有指定类的nodeList集合
           //返回document中类名为username 和current 的所有元素
            var allCurrentUserNames=document.getElementsByClassName("username current");

        //2.classList属性：
            //当一个元素中的类包含多个类名时，如果我们需要添加或者修改，一般情况下需要将整个类名获取，然后修改再添加，比较麻烦：
                //获取一个元素中的类名并将其分割，变成数组
                var className=document.getElementById("myDiv").className.split(/\s+/);
                //如果需要替换其中的一个名为user的类名
                var pos;
                for(var i=0;i<className.length;i++){
                    if(className[i]==user){
                        pos=i;
                        break;  //获取了该类名在数组中的位置 ，跳出循环
                    }
                }
                var newClassName=className.splice(i,1);//删除了这个类名
                var newClassName1=newClassName.join(" "); //数组以空格的方式连接成字符串
                document.getElementById("mydiv").className=newClassName1;

            //calssList属性是集合类型DOMTokenList的实例
            /*add(value):添加一个类
            *contains(value)：判断是否存在value这个类，如果存在，则为true
            * remove(value)：移除一个类
            * toggle(value):如果存在就删除这个类，如果不存在就添加这个类*/
                div.classList.remove("user");

        //焦点管理：
            //document.activeElement属性会引用DOM中获得了焦点的元素，文档加载期间为null值，加载完成时引用的是document.body.
            //document.hasFocus()判断文档是否获得了焦点

        //readyState属性：
            alert(document.readyState=="complete");    //加载完成   loading 正在加载中
        //自定义属性：
            //  <div id="myDiv" data-appId="123456" data-myname="niko"></div>  自定义需要添加data前缀
            //可以通过元素的dataset属性来访问，是DOMStringMap的一个实例
                div.dataset.appId="111111";     //设置了自定义属性的值

        //插入标记
            //innerHTML:读模式下，属性返回调用该属性的元素的所有子节点，写模式下，根据指定的值创建新的Dom树
                Element.innerHTML("<strong>strong word </strong>");
            //outerHTML：读模式下，属性返回调用该属性的元素的本身及所有子节点。其他类同innerHTML。

            //insertAdjancentHTML()方法：2个参数，第一个插入的位置 第二个插入的文本，第一个参数如下值：
            /*
            * beforeBegin:在元素之前插入一个同辈元素，把元素想象成一个框，内容在框内，beforeBegin就是在元素开始之前插入一个元素，也就是前                             面的一个紧邻的同辈元素了
            * afterBegin：元素开始之后插入一个元素，那就是在元素内部插入，而且是作为第一个元素
            * beforeend：元素结束之前插入，就是在元素的末尾插入，也就是作为最后一个子元素插入
            * afterend：元素结束之后插入，就是元素的下个一个同辈紧邻元素了*/
            element.insertAdjacentHTML("afterbegin","<p>Hello World</p>");

        //scrollIntoView()方法：
            //可以在所有HTML上调用，通过滚动浏览器窗口或者某个容器，调用元素就出现在视口中，如果有参数true那就是顶部对齐。可以用来做一个跟            随滚动的元素，比如导航？

        //innerText：获取当前元素中的文本。
        div.innerText=div.innerText;  //可以过滤掉元素内的所有标签


//*********************************************DOM2和DOM3****************************************************************
    //样式：
        //folat属性在执行样式操作时用cssfolat。
        mydiv.style.backgroundColor="red"; //设置mydiv的背景色为红色

        //style对象的一些属性和方法：（针对内联样式）
            //1.CSSText：获取style内部的css代码。也可以重写整个style内部的css代码，类似于innerHTML的做法
            mydiv.style.cssText="width:100px;height:200px;background-color=red";  //重写

            //2.length:style对象的长度，也代表几个css属性。
            //3.getPropertyValue(ProperName):获取css的属性的字符串值。
            porp=mydiv.style[2];    //取得第三个属性
            cssValue=mydiv.style.getPropertyValue(porp);

            //4.item(index):给定位置的CSS属性的名称，也可以使用style[index].
            //5.removeProperty(ProperName):删除某个css属性
            //6.setProperty(PropertyName,value,priority):给定属性设置为相应的值,并加上优先标志。


        //计算样式：document.defaultView.getComputedStyle()方法：
            //假设一个元素它有内联样式，也有内部样式表，还有外部样式表，但是style对象无法访问内外部样式表，就可以使用这个方法将元素所有的样式             都集中。像border这种综合性的属性可能无法返回
            var computedStyle=document.defaultView.getComputedStyle(myDiv,null);

            alert(computedStyle.backgroundColor);//获取背景色属性


        //操作样式表：CssStyleSheet类型
            //操作样式表的一般步骤：
                /*1.获取文档中的样式表信息，指定修改哪个样式表
                * 2.取得规则列表，通过索引的方式获取样式表中的某一条css规则，并对其进行修改（修改样式情况下）
                * 3.采用sheet.insertRule的方式在样式表中插入一条规则（插入规则情况下）,2个参数，css规则文本以及要插入位置的索引
                * 4.采用sheet.removeRule的方式在样式表中删除一条规则（删除情况下），1个参数，要删除位置的索引
                * */
                var sheet=document.styleSheets[0];      //获取第一个样式表
                var rules=sheet.cssRules;               //获取规则列表
                var rule=rules[1];                      //取得第一条规则
                var color=rule.style.backgroundColor;       //获取样式
                rule.style.backgroundColor="red";       //修改样式


                sheet.insertRule("#div{background-color:red; width:100px}",0);

        //元素大小：
        //遍历：
            //documunt.createNodeIterator()方法：
                //四个参数：
                    /*root:作为搜索起点的树中节点
                    * whatToShow：表示要访问哪些节点的数字代码  NodeFilter.SHOW_ELEMENT(显示元素节点 具体328页)
                    * filter：一个NodeList对象，或者表示一个应该接受还是拒绝的函数 不用时为null
                    * 第四个参数一般数false*/
                    filter={                            //一个过滤器
                        acceptNode:function (node) {
                            return node.tagname.toLowerCase()==p?
                                NodeFilter.FILTER_ACCEPT:
                                NodeFilter.FILTER_SKIP; //在treeWalker中有个FILTER_REJECT不是跳过当前节点而是跳过整个树
                        }
                    };
                    var iterator=document.createNodeIterator(root,NodeFilter.SHOW_ELEMENT,filter,false);

                //2个主要方法：nextNode(),previousNode()

                var node=iterator.nextNode();//第一次调用nextNode会返回根节点，遍历到最后一个再用此方法是会返回null
                while(node!=null){
                    alert(node.tagName);        //输出标签名
                    node=node.nextNode();
                }
            //document.createTreeWalker()方法：
                //基本类似于CreateNodeIterator方法，多了几个方法：
                    /*parentNode():查找当前节点的父节点
                    * firstChild():当前节点的第一个子节点
                    * lastChild():当前节点的最后一个子节点
                    * nextSibling():当前节点的下一个同辈节点
                    * previousSibling():当前节点的上一个同辈节点*/
                    filter={                            //一个过滤器
                        acceptNode:function (node) {
                            return node.tagname.toLowerCase()==p?
                                NodeFilter.FILTER_ACCEPT:
                                NodeFilter.FILTER_REJECT; //在treeWalker中有个FILTER_REJECT不是跳过当前节点而是跳过整个树
                        }
                    };
                    var walker=document.createTreeWalker(div,NodeFilter.SHOW_ELEMENT,filter,false);
        //范围：
            //首先认识四个参数:
                /*startContainer:被选择范围中第一个元素的父元素
                * startOffset：被选择范围中第一个元素相对其父元素的偏移量，也就是第一个元素的索引
                * endContainer:被选择范围中最后一个元素的父元素
                * endOffset：被选择范围中最后一个元素相对其父元素的偏移量，也就是它的索引值加1；
                * <body>
                *     <p id="1">hello</P>
                *      <div>
                *          <p >world</p>
                *          <p id="2">my name is fu</P>
                *      </div>
                *      </body>*/
                //以上述例子为例，如果要选择id=1的p到id=2的p元素的范围，那么，id=1的p元素为第一个元素，id=2的p元素为最后一个元素，startContainer就是body，startOffest为1（会有空白点），endContainer为div，endOffset为3（一个空白节点）。
                    var range=document.cerateRange();
                    range.selectNode(p1);           //选择怕p1元素以及它所有的子节点
                    range.selectNodeContents(p1);   //选择p1的所有子节点 不包括自己
                    range.setStrat(body,1);       //setStart方法：第一个参数就是第一个元素的startContainer，第二个参数就是startOffset
                    range.setEnd(div,3);        //同理，参数就是endContainer和endOffset

                //选择好了片段之后，我们会对片段进行一些操作，而且系统会自动给片段进行标签的补全。
                    range.deleteContents() ;    //  删除这个片段
                    var fragment=range.extractContents();   //移除范围片段，并返回这个片段
                    body.appendChild(fragment);         //将片段添加到其他元素中
                    var fragment1=range.cloneContents();        //创建一个片段的副本
                    range.insertNode(span);             //在片段之前插入一个节点span
                    range.surroundContents(span);        //将片段放在span中，即span元素环绕片段
                    range.collapse();           //该方法接受一个布尔参数，true值是折叠到起点，false是折叠到终点
                    alert(range.collapsed);      //折叠完毕后，使用collapsed检测起点终点是否重叠，true表示范围中没有内容。



//********************************************第十三章  事件    **********************************************

    //事件流：事件捕获  到   目标阶段   到  冒泡阶段

        //事件冒泡：从发生事件的元素开始，一直向上传播直到文档节点。如果每一级元素中都有指定该事件，则每个元素中的该事件都会被触发，且触发顺                   序是从目标元素开始到文档。
        //事件捕获：与事件冒泡相反的顺序执行事件。当一个目标元素发生事件，则从文档中开始向下传播，如果每一级元素中都有指定该事件，则每个元素                   中的该事件都会被触发，且触发顺序是从文档开始到具体的目标元素。



    //事件处理程序：
        //HTML事件处理程序：
            //<input type="button" value="click me" onclick="showmessage()">  在html元素中指定一个事件。缺点是js和HTML紧密耦合，如需              修改则2个都需要修改。

        //DOM0级事件处理程序：
            var btn=document.getElementById("mybtn");       //首先获得一个button元素的引用
            btn.onclick=function () {                       //为该元素指定一个事件，函数中的this值指向调用改事件的元素。
                alert("Click");
            };

            btn.onclick=null;       //删除事件处理程序

        //DOM2级事件处理程序
            btn.addEventListener("click",function () {
                alert(this.id);
            },false);                           //添加一个事件处理程序,最后一个参数值为false表示在冒泡阶段处理，true为在捕获阶段处理

            btn.removeEventListener("click",function () {
                alert(this.id)
            },false);               //删除一个事件处理程序，但是这里因为是匿名函数，所以无法删除，最好将函数单独列出再引用

            var handler=function () {
                alert(this.id)
            };                        //第二个参数引用handler即可。

        //IE事件处理程序
            var btn1=document.getElementById("mybtn");
            btn1.attachEvent("onclick",function () {
                alert(this===window) ;       //true     attachEvent中this的值指向window
            });
            btn1.attachEvent("onclick",handler);        //IE中添加的事件处理程序按添加的相反顺序执行。
            btn1.detachEvent("onclick",handler);

     //跨浏览器的事件处理程序：
        //添加一个包含所有方法属性的对象：
            var EventUtil={
                //添加一个事件处理程序：三个参数：要指定事件的元素，事件类型，处理函数
                addHandler:function (element,type,handler) {
                    //判断是否可以使用DOM2级处理程序
                    if(element.addEventListener){
                        element.addEventListener(type,handler,false);
                    }
                    //判断是否可以使用IE事件处理程序
                    else if(element.attachEvent){
                        element.attachEvent("on"+type,handler);
                    }
                    else{
                        element["on"+type]=handler;
                    }

                },
                //删除一个事件处理程序
                removeHandler:function (element,type,handler) {
                    if(element.removeEventListener){
                        element.removeEventListener(type,handler,false);
                    }
                    else if(element.detachEvent){
                        element.detachEvent("on"+type,handler);
                    }
                    else{
                        element["on"+type]=null;
                    }
                },
                //跨浏览器的事件对象

                //获取事件的event对象
                getEvent:function (event) {
                    return event?event:window.event;            //传入一个event对象参数，判断是否是可以直接引用还是在window中
                },
                //获取事件目标
                getTarget:function (event) {
                    if(event.target){
                        return event.target
                    }
                    else{
                        return event.srcElement;
                    }
                },
                //取消事件的默认行为
                preventDefault:function (event) {
                    return event.preventDefault?event.preventDefault():event.returnValue=false;
                },
                //阻止事件的冒泡
                stopPropagation:function (event) {
                    return event.stopPropagation?event.stopPropagation():event.cancelBubble=true;
                }
            };


        //事件对象：
            //当触发了某个事件时，会产生一个事件对象，对象的属性和值：
                /*bubbles:Boolean类型  表示事件是否冒泡
                * cancelable：Boolean类型  表示是否可以取消事件的默认行为
                * currentTarget：Element类型  表示事件处理程序所在的那个元素
                * target:Element类型   事件的目标
                * perventDeafult()：取消事件的默认行为
                * type:事件的类型
                * detali：事件的相关信息
                * stopPropagation():阻止事件的冒泡*/

                //target和currentTarget的区别
                document.body.onclick=function () {
                    //this和currentTarget都指向body元素，因为是body中的事件  this始终等于currentTarget
                    alert(event.currentTarget===document.body);             //true
                    alert(this===document.body);            //true

                    //event.target指向btn元素，因为btn是真正触发这个事件的元素
                    alert(event.target=document.getElementById("mybtn"));  //true
                };

                //阻止事件的默认行为
                var link=document.getElementById("mylink");
                link.onclick=function () {
                    event.preventDefault();                 //link中的链接就失效了
                };

                //阻止事件的冒泡

                var btn=document.getElementById("mybtn");
                btn.onclick=function () {
                    alert("I am in btn");
                    event.stopPropagation();            //冒泡事件被阻止
                };
                document.body.onclick=function () {
                    alert("I am in body");              //body中的事件不会被执行了
                                                        //如果把body添加到捕获阶段，那么冒泡阻止的方法就失效了
                };

        //IE中的事件对象:
            //使用DOM0级的方法添加事件处理程序中：
                btn.onclick=function () {
                    var event=window.event;         //event作为window的一个属性存在
                    alert(event.type);
                };
            /*cancelBubble:设置为true是可以取消事件冒泡
            * returnValue：默认为true，设置为false时取消事件的默认行为
            * srcElement：同DOM中的target，事件的目标
            * type：事件的类型*/

        //事件类型：
            //UI 事件
                //load事件 ：页面加载完成后，在window上触发的事件，图像加载完毕时在img元素中触发，img元素只要设置了src就会开始下载
                //unload事件：文档被卸载后触发。主要用来清除引用
               window.addEventListener("unload",function () {
                alert(Unload);
                });
                //scroll事件
                scrolltop=document.documentElement.scrollTop;

            //焦点事件：
                //配合document.hasFocus() 元素是否获得焦点？   和document.activeElement指向获得焦点的元素
                //6个焦点事件：
                    /*blur:失去焦点是触发 不会冒泡
                    * focus：获得焦点是触发 不会冒泡
                    * focusin：获得焦点时触发 但是会冒泡
                    * focusout：失去焦点时触发 会冒泡*/

            //鼠标滚轮事件：
                //1.客户区坐标位置：
                div.addEventListener("click",function () {
                    alert("Client coordinates:"+event.clientX+","+event.clientY);
                });
                //2.页面坐标位置：
                div.addEventListener("click",function () {
                    alert("Page coordinates:"+event.pageX+","+event.pageY);
                });
                //没有滚动的情况下，2者相等。

                //IE8之前的版本不支持pageX和pageY，可以使用clientX+scrollLeft 和 clientY+scrollTop的方式计算得出

                //修改键：鼠标事件中：event.shiftKey  (ctrlKey  altKey  metaKey)  这些属性中包含的都是布尔值，相应 的键按下了就是true

                //相关元素:

                //鼠标按钮：对于mousedown和mouseup事件，其event有个event.button属性，值为0表示猪鼠标按钮，1表示中间的鼠标按钮，2表示次鼠                             标按钮

                //更多事件信息：

                //鼠标滚轮事件：mousewheel事件

                document.addEventListener("mousewheel",function () {
                    alert(event.wheelDelta);        //该事件对象中有个wheelDelta属性，显示滚动的值
                });

                //键盘于文本事件：
                    /*keydown事件：按下任意键触发
                    *keyup事件：释放按键是触发
                    * keypress：按下键盘上的任意字符键触发（不同于keydown）*/
                    //键盘事件中也有类似与鼠标事件中的修改键

                    //发生keydown和keyup时，事件的event会有一个keyCode的属性，值为一个代码，与相应的键对应。
                    //发生keyPress时，事件的event会有一个charCode的属性
                    //textInput事件：用户在可编辑区域输入字符时触发该事件。区别于keyPress,第一keyPress在任何获得焦点的元素上都可以触发，                        而这个事件只能触发在可编辑区域，第二，该事件只有在用户输入实际的字符键时才能触发，二keypress在按下那些能够影响文本                       显示的键时也会触发。
                    //textInput事件的event中有个data属性，属性值就是用户输入的字符。


         //HTML5事件
            //contextmenu事件：点击鼠标右键可以调出上下文菜单
                document.addEventListener("contextmenu",function (event) {
                    event.preventDefault();             //先取消默认的上下文显示
                    var menu=document.getElementById("myMenu");
                    menu.style.left=event.clientX+"px";         //获得鼠标点击的坐标并赋值给menu
                    menu.style.top=event.clientY+"px";
                    meun.style.visibility="visiable";           //显示自定义的上下文菜单

                });
                document.addEventListener("click",function () {
                    document.getElementById("myMenu").style.visibility="hidden";//点击后隐藏上下文菜单
                })

            //beforeunload事件：
                //在页面关闭之前弹出一个框来让用户确定是否退出。
                window.addEventListener("beforeunload",function(event){
                    prompt("是否离开？");
                    var message="I am really going to miss you if you go";
                    event.returnValue=message;
                    return message;
                });

            //DOMContentLoaded事件：
                //在DOM树加载完成之后就会触发，document中的事件。
                document.addEventListener("DoMContentLoaded",function () {
                    alert("content loaded")
                });


            //pageshow和pagehide事件：
                window.addEventListener("pageshow",function () {
                    alert(event.persisted);//persisted属性，如果是从bfcache中读取而来的，那么就为true，所以第一次加载时肯定是false


                });//当页面加载成功时就会第一次触发这个事件，如果页面从bfcache中读取而来，会在完全恢复的时候触发

                window.addEventListener("pagehide",function () {
                    alert(event.persisted);//如果页面卸载之后保存在bfcache中，那么这个事件的persisted属性就是true。
                });


            //haschange()事件：window对象中的事件，event包含2个属性oldURL和newURL，保存着变化前后的url的值
                window.addEventListener("haschange",function () {
                    alert("old url"+event.oldURL);
                });


        //性能和内存:
            //事件委托：当一个事件被多个元素共同注册的时候，可以利用事件冒泡的机制，将该事件添加到这些元素的共同父类中，从而不必为每个元素添               加事件处理程序,鼠标事件或者键盘事件都适合采用。
            var list=document.getElementById("list");//这个列表中有三个子元素，每个子元素都有click事件
            list.addEventListener("click",function (event) {
                switch (event.target.id){
                    case "dosomthing":
                        document.title="i change";
                        break;
                    case "gosomewhere":
                        alert("yiwu");
                        break;
                }
            });
            //移除事件处理程序，当元素被innerHtml或者removeChild replaceChild时，它所绑定的事件处理程序需要被清除，不然会占用过多的内存


        //模拟事件：

            /*UIEvents:一般化的UI事件
            * MouseEvents：鼠标事件
            * KeyboardEvent:键盘事件
            * HTMLEvents：一般化的HTML事件*/

            //模拟鼠标事件：
            var event=document.createEvent("MouseEvents");//使用createEvent创建一个鼠标事件
            event.initMouseEvent("click",.......)// 有15个参数，详见406
            btn.dispatchEvent(event);   //触发事件，参数为要触发的事件



//***************************************************** 表单脚本******************************************************
    //表单基础知识
        /*name:表单的名称
        * target:发送和接受请求的窗口
        * method：要发送的http请求 get或post
        * action:请求接受的url*/
        //获取表单的几种形式：
            var form=document.getElementById("from1");
            var firstForm=document.forms[0];
        //提交表单：
            //在表单中定义一个button（type也要为submit）或者submit或者image，按下回车会自动提交表单。
            //<button type="submit">submit form</button>
            //注意：当表单中只有一个文本框时，有type="button"或者是<button></button>的按钮，按下回车会自动提交表单(多个文本框时不会提交)
            //提交表单时会进行验证，或者可以使用event.preventDefault()来添加事件取消验证
            form.addEventListener("submit",function (e) {
                e.preventDefault();
            });
            //也可以使用js的形式来提交表单，但是不会验证
            var form1=document.getElementById("from1");
            form1.submit();
            //当用户多次提交时，可以禁用提交按钮，或者利用onsubmit事件处理程序取消后续的提交操作

        //重置表单：type特性设置为reset的input或者button
        //表单字段：
            //表单有个element属性，是所有字段的集合，HTMLCollection的实例。
            var field1=form.elements[0];
            //假如表单中有三个name属性都是color的字段
            var fieldColor=form.elements["color"];//可以获得name属性为color的所有字段 返回一个NodeList
            var fieldColor1=fieldColor[0];

            //表单字段共有的属性：
                //除了form之外，其他属性都可以通过js来修改

                /*disable：表单是否被禁用
                * form：当前字段所属表单的指针。如果字段中form属性为form="form1"，那么该字段属于表单form1
                * name:名称
                * readOnly：表单是否是只读的
                * tabIndex：当前字段的切换序号
                * value：当前字段被交给服务器的值*/
                //为避免用户的多次提交问题，可以使用添加一个submit的事件处理程序，不能用click
                form.addEventListener("submit",function () {
                    event.target.elements["submit-btn"].disable=true;
                });
                //select元素的type是只读的，input和button的是可以修改的。

            //共有的表单字段方法：focus() blur()
                //表单字段中的autofocus属性会把焦点自动移动到相应字段而不用指定

            //表单字段的共有事件
                //focus blur change
                //change事件：在input和textarea中，只有获得焦点，改变value值然后失去焦点之后触发，在select中是改变了选项触发。需要注意的                    是在不同的浏览器中触发blur和change的时间会有所不同。
        //文本框脚本
            //input type="text"  value特性可以设定初始值，size特性设置文本框能显示的字符数，maxlength设置输入的最大字符数，如需限制最小               字符数，可以在onsubmit中加入一个验证的方法。
            //textarea 元素：使用rows和cols指定大小，初始值写在<textarea></textarea>之间。

            //这两种方法都会将值保存在value之中。使用属性读取或者设置value的值，不要使用setAttribute()来设置value特性的值

        //选择文本：
            //select()方法：会选择调用该方法的字段中的所有文本。当字段获得焦点是经常会调用这个方法来选中所有文本。
            //select事件:选择了文本框中的文本是会触发这个事件。
                //如何获取被选择的文本？
            var textbox=document.getElementById("form1").elements["textbox1"];
            textbox.addEventListener("select",function () {
                start=textbox.selectionStart;           //获取选择文本段开始字符的偏移量
                end=textbox.selectionEnd;           //获取选择文本段结尾字符的偏移量
                selectedText=event.target.value.substring(start,end);   //substring方法来截取该字段
            });
            //setSelectionRange()方法：2个参数，类似于substring，第一个位置的索引和最后一个位置的索引。
                textbox.setSelectionRange(0,5);  //选择了从第一个字符开始的5个字符
        //过滤操作：
            //1.屏蔽字符：
                //极端情况下，可以直接屏蔽keypress事件 如：
                    textbox.addEventListener("keypress",function () {
                        event.preventDefault();
                    });

                //屏蔽非数值的情况
                    textbox.addEventListener("keypress",function () {
                        //匹配到不是数值的情况下,有些浏览器有些非字符键也会触发可以keypress，且charcode值小于都9，所以，为了不屏蔽这些键                          要加上charCode>9的条件。最后一个条件是除了ie之外的浏览器也会屏蔽Ctrl，所以检测到是ctrl的就不屏蔽了
                        if(!/\d/.test(string.fromCharCode(event.charCode))&&event.charCode>9&&!event.ctrlKey){
                            event.preventDefault();
                        }
                    });
               //操作剪贴板
                    //6个事件：这些事件发生时event中有clipboardData属性，这个属性在ie是在window对象中
                    /*copy：复制时触发
                    * cut：剪切时触发
                    * paste：粘贴操作时触发
                    * beforecopy beforecut beforepaste*/
                    // clipboardData对象有三个方法：getData(),setData("text"ie中/("text/plain")Safari和Chrome中,value),clerData()
                    textbox.addEventListener("paste",function () {
                        //只有paste事件时才能使用getData方法（除了ie）
                        value=event.clipboardData.getData("text");     //Safari Chrome Firefox中 参数是mime类型
                        value=window.clipboardData.getData("text");       //ie中  参数是text和url
                        //判断是不是数值，不是就阻止粘贴操作。
                        if(!/^\d*$/.test(value)){
                            event.preventDefault();
                        }
                    });
                //自动切换焦点
                    (function () {
                        form=document.getElementById("form1");  //获取表单
                        var numberArea=form.elements["phoneNumber"];    //获取表单中name属性是phoneNumber的字段
                        function tabForward() {
                            if(event.target.value.length==event.target.maxLength){  //判断输入的字符长度是否和最大长度相等
                                for(var i=0,len=numberArea.length;i<len;i++){
                                if(event.target==numberArea[i]){           //循环判断现在输入的是第几个字段，然后让下一个字段获得焦点
                                    if(numberArea[i+1]){
                                        numberArea[i+1].focus();
                                    }
                                }
                            }
                        }
                        }
                            var textbox1=numberArea[0];
                            var textbox2=numberArea[1];
                            var textbox3=numberArea[2];
                            textbox1.addEventListener("key",tabForward);
                            textbox2.addEventListener("keyup",tabForward);
                            textbox3.addEventListener("keyup",tabForward);

                    })();


        //HTML5中的约束API 就是不依赖于js
            //必填字段  在字段中指定required属性 适用于input textarea select字段

        //选择框脚本
            //通过<select><option>创建的

            /*add(newOption,relOption):2个参数，要插入的选项，位置在relOption之前。
            * multiple：是否可以选择多项，等价于HTML中的multiple特性
            * options:控件中所有option的HTMLCollection
            * remove(index):移除选中项
            * selectedIndex：基于0的选中项的索引，没有选中项则为-1,
            * size：选择框中可见的行数*/


            //关于选择框中的value值：
                /*1.如果没有选中项，则为空值
                * 2.如果有选中项，且选中项中value值在html中有指定，那就是选中项的value值
                * 3.如果有选中项，但是选中项的value值在HTML中没有指定，那么，选择框的value值就是选中项的文本值
                * 4.如果有多个项，那就取第一个项*/

            //关于option中的各个属性：
                //为了方便访问option，设定了几个属性：
                /*index:当前option在options中的索引
                * selected：表示是否被选中，将该值设置为true可以被选中
                * text:option中的文本
                * value：option中value的值*/

                var selectbox=document.getElementById("form1").elements["selectlist"];//选择一个下拉菜单
                text1=selectbox.options[0].text;        //获取第一项的文本
                value1=selectbox.options[0].value;      //获取第一项的值

            //如何获取下拉菜单的选中的值呢？
                //1.如果选项只有一项，可以使用selectIndex属性
                selectedOption=selectbox.selectedIndex;     //获取选项的索引值
                textOption=selectbox.options[selectedOption].text;  //直接选出该值获取其text

                //2.如果选项有多个选项值，就不能使用selectIndex，它只能取回选中的第一项的值。
                //使用循环迭代每个选项，判断其selected属性
                function getSelectedOptions() {
                    var aryOption=[];
                    for(var i=0,len=selectbox.options.length;i<len;i++){
                        var optionSel=selectbox.options[i];
                        if(optionSel.selected==true){
                            aryOption.push(optionSel);      //将符合的选项加入数组
                        }
                    }
                    return aryOption;
                }

            //添加选项：
                var newOption=new Option("Option text","Option value");//生成一个新的Option
                selectbox.add(newOption,undefined);          //将新的选项添加到最后，第二个参数也可以自己指定，为要插入选项的后一个选项
            //删除选项：
                selectbox.remove(index);

            //移动和重排选项：
//              移动：可以使用appendChild()方法
                var selectedBox1=doucument.getElementById("setLocation1");
                var selectedBox2=doucument.getElementById("setLocation2");
                selectedBox2.appendChild(selectedBox1.options[1]);  //把selectedBox1中的第二项添加到selectedBox2中
                //重排的方法可以使用insertBefore()方法

        //表单序列化：
            function serialize(form) {
                var arySer=[];
                for(var i=0,len=form.elements.length;i<len;i++){
                field=form.element[i];
                switch (field.type){
                    case "select-one":
                    case "select-multiple":
                        if(field.name.length){
                        for(var j=0,len1=field.options.length;i<len1;j++){
                            if(field.options[j].selected){
                                option=field.options[j];
                                optValue="";
                                if(option.hasAttribute){
                                optValue=option.hasAttribute("value")?option.value:option.text;}    //DOM中
                                else{
                                    optValue=option.attributes["value"].special?option.value:option.text}//IE中
                                arySer.push(encodeURIComponent(field.name)+"="+encodeURIComponent(optValue));//编码后加入数组中
                            }
                        }
                    }
                    break;
                    case "file":                //这些类型的字段被忽略
                    case undefined:
                    case "submit":
                    case "reset":
                    case "button":
                        break;
                    case"radio":
                    case"checkbox":
                        if(!field.checked){         //如果控件没有被选中，就跳出
                            break;
                        }
                    default:
                        //没有名字的字段不序列化
                        if(type.name.length){
                            arySer.push(encodeURIComponent(field.name)+"="+encodeURIComponent(field.value));
                        }
                }
            }
            return arySer.join("&");
        }


//***********************************************************Canvas绘图************************************************
    //2D上下文和3D上下文的概念：2D上下文是在canvas内绘制2D图形的能力，3D上下文现在还没有得到比较好的支持

    //首先，要绘图，要新建一个canvas，可以为其添加样式或者在元素内绘图。
    //<canvas id="drawing"  width="200" height="200">A drawing Of Something</canvas>  如果浏览器不支持canvas 就会出现标签内的文字

        var drawing=document.getElementById("drawing");
            if(drawing.getContext){     //判断是否支持getContext
                var context=drawing.getContext("2d");//调用getContext并传入上下文名字
            }

    //如果在canvas中创建了一个图像，想导出可以使用toDataURL()方法：
        //假设已经绘好了图
        var imgURL=drawing.toDataURL("image/png");  //参数为图像的MIME类型格式
        var image=document.createElement("img");        //创建一个img元素
        image.src=imgURL;                   //指定其src为imgURL
        document.body.appendChild("image");


    //2D上下文：
        //其中有2个值是适用到所有的方法，包括矩形绘制，路径绘制，文本绘制等，所有的图像都要用他们来填充或者描边
        var drawing=document.getElementById("drawing");
        if(drawing.getContext){     //判断是否支持getContext
            var context=drawing.getContext("2d");//调用getContext并传入2d上下文名字
        }
            context.fillStyle="#0000ff";        //填充颜色为蓝色   也可以设置为raga(0,0,255,0.5)的格式，最后一个参数为透明度，0为透明
            context.strokeStyle="red";          //描边颜色为红色

     //绘制矩形：
        //矩形是在2D上下文中唯一一种可以直接绘制的形状。三种方法：fillRect()  strokeRect()  clearRect()
            //context已经调用getContext并传入2D上下文
            context.fillStyle="#ff0000";
            context.fillRect(10,10,50,60);      //四个参数：矩形左上角的点坐标，以及矩形的宽度和高度值

            context.strokeStyle="rgba(0,0,255,0.5)";
            context.strokeRect(30,30,50,50);

            context.clearRect(40,40,10,10); //清除画布上的矩形区域


    //绘制路径：

        //首先，调用beginPath()方法，表示开始绘制新路径，结束后调用ClosePath()方法。路径完成后可以调用fill()方法填充，或者调用stroke()方          法对路径描边，还可以使用clip()方法在路径上剪切一个区域。具体绘制方法和参数详见449。

        //isPointPath()方法：接受一个坐标为参数，判断坐标是否在绘制的路径上
            if(context.isPointInPath(100,100)){
                alert("改点在路径上！");
            }

    //绘制文本
        //绘制文本的2个方法：fillText()  strokeText()  ,并以三个属性为基础
        context.font="bold 14px Arial";     //font属性，和在CSS中指定的方式相同
        context.textAlign="center";         //文字相对于其坐标点是居中还是靠左(end)或者靠右(start)
        context.textBaseline="middle";      //垂直方向文字相对于坐标点的对齐方式

        context.fillText("12",100,20);      //第一个参数：要绘制的文本，第二三 个参数：文本要绘制的坐标

    //变换：
        /*ratate(angle):angle 表示弧度 (角度/360)*2pai=弧度
        * scale(scaleX,scaleY):缩放图像，x方向乘以scaleX,y方向乘以scaleY，2个参数默认都是1
        * translate(x,y):将坐标原点移动到(x,y)*/

    //绘制图像：
        var image=document.createElement("img");        //创建一个图像元素
        image.src="/fuzhengsong/images/task07/icon-1.png";  //设置图像的src
        context.drawImage(image,10,10,50,50);         //画图，二三参数为图像起始点，四五为图像的大小，没有四五参数则为默认大小
        //drawImage可以将canvas元素作为其第一个参数

    //阴影：
        //2D上下文阴影属性值：
        /*shadowColor：阴影颜色
        * shadowOffestX：形状或者路径x轴方向的偏移量
        * shadowOffestY：形状或者路径y轴方向的偏移量
        * shadowBlur：模糊的像素数。*/

    //渐变：线性渐变由CanvasGradient实例表示
        var gradient=context.createLinearGradient(30,30,70,70);  //创建一个渐变，从30,30,到70,70
        gradient.addColorStop(0,"red");         //参数:色标位置和颜色的值
        gradient.addColorStop(0.5,"green");
        gradient.addColorStop(1,"blue");
        context.fillStyle=gradient;         //把渐变赋值给fillStyle
        context.fillRect(30,30,50,50);      //按渐变的方式来说 这里是从30,30到80,80,多出来的部分显示最后位置为1的颜色

        //放射渐变使用createRadialGradient()方法
        var gradient1=context.createRadialGradient(55,55,10,55,55,30);//创建一个渐变，前三个是起始圆的圆点和半径，后三个是结束圆的起点                                                                         和半径。

    //模式：就是重复的图像，可以用来填充和描边图形。从画布的起点开始填充或者描边图形
        var image=document.image[0];//获得或者创建一个图像
        pattern=context.createPattern(image,"repeat");  //第二个参数包括repeat，repeat-x，repeat-y

    //使用图像数据
        var imageData=context.getImageData(10,5,50,50); //前2个参数为获取图像的左上角坐标，后两个为图像的大小
        //imageData中有3个属性，width，height,data。data是一个数组，保存着每个像素的数据，每4个数组项保存着一个像素的信息。分别表示红绿蓝       和透明度值。可以在修改了图像data之后，使用putImageData()方法把图像数据绘制到画布上。

    //合成：
        context.globalAlpha=0.5 ;        //全局透明度，设置该属性后，后续的上下文都是半透明状，直到重置该值默认为0

        context.globalCompositeOperation="";    //表示后面的图形和之前的怎么样结合（在上或者在下，隐藏或是显示等），有很多可选的值。P463

    //WEBGL



//HTML5脚本编程：
    //跨文档的消息传递：XDM，核心方法是postMessage()方法。
        //发送消息
        var iframeWindow=document.getElementById("myframe").contentWindow;      //接受窗口的一个引用
            /* 引用有以下几种形式：
            (a)、window.frames[0].postMessage
            (b)、document.getElementsByTagName('iframe')[0].contentWindow
            (c)、window.opener.postMessage
            (d)、event.source.postMessage
            */
        iframeWindow.postMessage("A secret","http://www.wrox.com"); //2个参数，第一个是传递的消息，第二个参数是接受方域的字符串。如果                      第一个参数需要传入结构化的数据，可以调用JSON.stringify()的方法，然后在onmessage事件处理程序中调用JOSN.parse()。

        //接受数据：在接受消息的框架中设置一个onmessage事件处理程序，在接受到信息时触发。event有3个属性值：
        /*data:传入的字符串数据
        * origin:发送消息的文档所在的域
        * source：发送消息的文档的window对象的代理，用于发送方调用postMessage()方法，这里是iframeWindow*/

            window.addEventListener("message",function (event) {
                data1=event.data;           //接受到的数据
                event.source.postMessage("Received!","http://p2p.worx.com"); //向发送信息的域发送回执。
            });

    //原生拖放：
        //拖放事件：
            //拖动时依次触发  dragstart drag（鼠标拖住移动时持续触发） dragend
            //拖动到放置目标上时，触发 dragenter（进入目标）  dragover（在目标上移动）  dragleave（离开目标）或者drop

        //任何元素都可以变成有效的放置目标(原本默认是不可放置的)，只要重写其dragenter和dragover事件即可。
            element.addEventListener("dragenter",function (event) {
                event.preventDefault();           //阻止元素的默认操作
            });
            element.addEventListener("dragover",function (event) {
                event.preventDefault();           //阻止元素的默认操作
            });



         //dataTransfer对象：2个主要方法setData()和getData()
            //setData()方法2个参数，第一个为数据类型，ie中表示为“text"或者“url”，在H5规范中为“text/plain”和“text/uri-list”,在拖放时                 dataTransfer对象可以为每种数据类型都保存一个值,第二个参数为数据类型对应的值。
            element.addEventListener("dragstart",function (event) {          //drag事件时触发
                event.dataTransfer.setData("text","some text");
                event.dataTransfer.effectAllowed="move";            //设置什么样的
            });

            //getData()方法：一个参数，也就是setData中的第一个参数
            element.addEventListener("drop",function (event) {          //在drop中调用数据
                var text=event.dataTransfer.getData("text");
            });


        //一个例子：
            var div=document.getElementById("div1");
            var image1=document.getElementById("image");
            //元素进入区域时
            div.addEventListener("dragenter",function (event) {

                event.preventDefault();         //阻止默认操作
                event.dataTransfer.dropEffect="move";
                //return true;
            });
            div.addEventListener("dragover",function (event) {

                event.preventDefault();         //阻止默认不可放置的操作
                //return true;
            });

            //开始拖动时，设置数据
            image1.addEventListener("dragstart",function (event) {
                event.dataTransfer.effectAllowed="move";
                event.dataTransfer.setData("Text",event.target.innerHTML);
            });
            //放置元素时，读取数据
            div.addEventListener("drop",function (event) {
                event.preventDefault();
                data=event.dataTransfer.getData("Text");
                event.target.innerHTML=data;
            });




 //*************************************************  第四章 变量l、作用域和内存问题**************************************


 /*基本类型的值：Boolean String Number Null Undefined
         引用类型的值：Object
         区别：基本类型的值被复制的时候会生成一个新的变量，且两个变量互相不影响。引用类型的值被复制时，同样将值复制到新的
         变量中，但是复制的是一个引用，指向储存在堆中的同一个对象，会互相影响。
         */




/*检测类型：
        基本数据类型：typeof()*/
        var s="name";
        var n=null;
        var o=new Object();
        var colors=new Array();
        alert(typeof s);//      String
        alert(typeof n);//      Object
        alert(typeof o);//      Object
        alert(typeof colors);    //Object

        /*引用数据类型：instanceof()
         上述代码中可以看出在测试引用类型值时只返回Object 却并不知道是什么类型的对象，这时可以使用instanceof()*/
        var person=new Object();
        var colors=new Array();
        alert(person instanceof Object);//  true
        alert(colors instanceof  Array);//  true
        alert(colors instanceof  Object);//  true

        /* 所有引用类型的值都是引用类型的实例(统称为Object类型)，引用类型有 Object Array RegExp正则表达式 function 基本包装类型，               所有对这些实例instanceof Object都是返回true*/


//执行环境和作用域

        // 每个函数都有自己的执行环境， 最开始只有一个arguments对象（可以使用该对象来访问保存参数的数组，arguments[0]表示第一个
//         参数）。

/*      代码在执行环境中时，会创建一个作用域链，如果是函数，作用域链最前端就是其本身的arguments对象，下一个对象就是其包含环境
        中的对象，依次向上最终是全局环境(window对象)。包含环境中的对象可以被其内部执行环境所调用，因为执行环境的作用域链中可以找到
        这个对象，但是内部环境中的对象无法被外部环境所调用。                   */

//      延长作用域链：1.try-catch语句中的catch块 2.with语句。

//      来看一个例子：
//  try-catch：
//       HTML代码：
        /*<h1>My First JavaScript</h1>
        <p>Please input a number between 5 and 10:</p>
        <input id="demo" type="text">
            <button type="button" onclick="myFunction()">Test Input</button>
        <p id="mess"></p>*/
        function myfunction(){
            try{
                var value=document.getElementById("demo").value;
                if(value=="")  throw "值为空";
                if(isNaN(value)) throw "不是数值";   //检测是不是 ‘不是数值’
            }
            catch(err){                  //catch块延长了作用域，catch作用域内有一个err对象，外部无法访问，执行后被销毁
                var message=document.getElementById("mess");
                message.innerHTML=err;          //catch块的外部无法访问到err对象  但是message变量可以在函数执行环境中被访问。
                var mes=err;               //把err赋值给mes，mes可以在函数执行环境被访问
            }
            alert(err);     //无法被访问，程序中断
            alert(mes);     //err中的信息
        }

    //with():
        function buildUrl() {
            var qs="?debug=true";
            with(location){         //with()接受了一个location对象，延长了作用域链
                var url=href+qs;       //href 实际上等于location.href
            }
            return url;            //url在函数环境中也可以被访问。
        }



//*************************************************   引用类型 (重点内容)**********************************************

//        所有引用类型的值(对象)都是引用类型的实例(统称为Object类型). 细分的话，有：Object 类型、Array 类型、Date 类型、
//         RegExp 类型、Function 类型 等   对象可以使用new操作符后面加一个构造函数来实现。
                var obj=new Object();
                var ary=new Array();
                var dat=new Data();

//Object类型：


//  两种创建方法：
//      方法一：构造函数法

            var person=new Object();
            person.name="Nicholas";
            person.age=29;          //定义两个属性，两个值

        //方法二：字面量法

            var person={
                person:"Nicholas",
                age:29
            };

//************* 注意：一般来说 ，访问对象是用的是点表示法，如person.name，但是 如果需要通过变量来访问属性时，需要使用方括号表示法
//                     如属性名中有关键字和保留字时，也可使用方括号表示法
        var aqiData={
            北京:60,
            上海:90
        };
        var cityStr =北京;
        alert(aqiData[cityStr]);     // 60
        alert(aqiData.cityStr);       //undefined


//Array类型：

    //两种创建方法：

        //方法一：构造函数法
            var ary=new Array();
            var ary=new Array(20);          //有20项长度的数组
            var colors=new Array("red","blue","green");       //长度为3且值确定的数组

        //方法二：字面量表示法

            var colors=["red","blue","green"];      //3项的数组
            var names=[];

        //设置和读取数组中的值时，可以使用方括号法 如colors[0],上面的colors中：
            alert(colors[0]);      //red
            colors[1]=black;        //blue的值变为black
            colors[3]=brown;          //新增一项在第四位
            colors[99]=pink;           //新增一项在第100位，数组长度变为100,5-99位为undefined
            alert(colors.length );       //100

        //length属性可以用来移除或者添加项。
            colors.length=50;       //移除后面的50项
            colors[length]="white";     //在数组的第51位添加一项


    //检测数组：

        if(array.isArray()){
            //操作
        }
        //instanceof操作符在一个全局作用域中也可以进行检测，但是在网页中包含多个框架（多个全局环境时），无法使用。

    //转换方法：

        //1.toString()方法：返回数组的字符串表示，中间用逗号隔开。

        //2.valueOf()方法：返回还是一个数组

        //3.toLocalString()方法

            var colors=["red","blue","green"];
            alert(colors.valueOf());        //red,blue,green
            alert(colors.toString());       //red,blue,green
            alert(colors.toLocaleString()); //red,blue,green

            var color=colors.valueOf();     //color还是一个数组

        //4.可以使用join()方法来使用不同的分隔符构建字符串

            alert(colors.join("||"));    //red||blue||green


    //栈方法：

        //后进先出：
            var colors=[];
            colors.push("red","blue");          //返回修改后数组的长度
            colors.pop();                       //返回移除的项（最后一项） 这里是blue

    //队列方法：

        //先进先出：
            var colors=[];
            colors.push("red","blue");
            colors.shift();             //返回移除的项（第一项） 这里是red

        //unshift()方法可以从前端添加项
            colors.unshift("green","brown");    //green brown blue
            colors.pop();                       //blue

    //重排序方法：
        //1.reverse()方法  将数组内项的次序反转

        //2.sort()方法

            var values=[0,1,5,10,15];
            values.sort();
            alert(values);              //0 1 10 15 5

            //使用sort()方法排序是默认是从小到大的顺序，现将数组内的项使用toString()方法转化成字符串，比较字符串排序，效果不理想
            //因此 sort()方法可以接受一个比较函数
            values.sort(function (a,b) {
                if(a<b){                        //如果a 要在b之前，返回一个负数
                    return -1;
                }
                else if(a>b){                    //如果a 要在b之后，返回一个正数
                    return 1;
                }
                else{
                    return 0;
                }
            });

            //如果数组中的项为数值类型或者valueOf会返回数值类型的对象类型，更加简便的方法
            values.sort(function (a,b) {
                return a-b;                             //升序排列
            });


    //操作方法：

        //1.concat()方法：可以合并数组或者添加新项，返回一个新的数组，原来调用该方法的数组保持不变

            var colors=["red","blue","green"];
            var colors2=colors.concat("yellow",["black","brown"]);  //colors2为一个新的数组，不同于colors

        //2.slice()方法：2个参数，如果只使用一个时，返回从该位置到数组末尾所有项，如果有2个参数时，返回从起始位置到结束位置
           // 中间的项，但不包括结束项。如果参数为负数，则用该参数加上数组的长度来确定相应的位置。

        //例如：有个10项的数组，那么：
            ary1=ary.slice(3,6);
            ary2=ary.slice(-7,-4);
            alert(ary1==ary2);      //true

        //3.splice()方法：3个参数，第一个是起始位置，第二个是要删除的项数(从起始位置开始删除)，第三个是要插入的任意个数的项(删除项数之后，
                        // 在起始位置的地方插入)  返回的是被删除的项。

    //位置方法： 2个参数，要查找的项以及表示查找起点位置的索引。返回要查找的项在数组中的位置,没有时返回-1
        //1.indexOf()
        //2.lastIndexOf()

            var person={
                name:"Nicholas"
            };
            var people=[{name:"Nicholas"}];
            morePeople=[person];
            alert(people.indexOf(person));          //-1
            alert(morePeople.indexOf(person));       //0

    //迭代方法：2个参数，第一个数函数，第二个是运行该函数的作用域对象(影响this的值)也就是函数在哪个作用域中运行，都是给数组中的每一项运行给定               的函数。函数有3个参数，数项的值，该项在数项中的位置，数组对象本身。

        //1.every()     函数对每一项返回true 则返回true
        //2.filter()    返回该函数会返回true的项组成的数组，可以用来筛选数组中满足条件的数项，比较有用。
        //3.forEach()     对所有数项运行函数，不返回值
        //4.map()       返回运行函数后返回的值组成的数组，没有筛选
        //5.some()       对任意一项返回true，则返回true。

            var filterResult=numbers.filter(function (item,index,array) {
                //执行操作
            });

    //归并方法：2个方法 都会迭代数组的所有项，构建一个最终返回的值。2个参数，一个函数，作为归并基础的初始值。函数有4个参数：
//              前一个值，当前值，项的索引，数组对象。函数返回的任何值都会作为第一参数传给下一项。
        //1.reduce()
            var values=[1,2,3,4,5,6];
            var sum=values.reduce(function (prve,cur,index,array) {
                return prve+cur;
            });
            alert(sum);             //15

        //2.reduceRight() 从后面开始遍历。


//Data类型******************

    //创建一个日期对象
        var now=new Date();        //如果data()内没有参数，则获取当前的日期
        var now1=new Date("2016-01-01");    //  01/01/2016或者January 01,2016或者  UTC格式2016,0,1(月份从零开始算)

    //取得调用该方法时的时间和日期的毫秒数        可以用来计数时间
        var start=Date.now();

    //valueOf方法:
        var date1=new Date("2007,0,1");
        var date2=new Date("2007,1,1");
        alert(date1<date2);             //true  自动调用valueOf方法，把日期转化成毫秒数来比较

    //日期的格式化方法：将日期格式化为特定的形式。p101;


    //日期组件方法：
        var date=new Date();
        alert(date.getTime());          //与valueOf方法相同效果
        alert(date.getFullYear());       //获取年份值 4位
        date.setFullYear("2017");          //设置年份 传入必须是4位数
        alert(date.getMonth());             //注意：获取的月份中0-11表示1月-12月
        alert(date.getDate());              //获取日期
        alert(date.getDay());                  //获取星期数 0-6表示星期日-星期六


//************************RegExp类型
        var expression=/pattern/flags;
//  正则表达式是什么？

     //正则表达式2种创建方法：
    //       1.字面量法：

        var partten1 = /[bc]at/gi;            //匹配bat或者cat
        var partten3 = /\[bc\]at/gi;          //匹配[bc]at

//       2.构造函数法：

        var partten2=new RegExp("[bc]at","gi");  //如果有转义的字符，在函数内需要双重转义
        var partten4=new RegExp("\\[bc\\]at","gi");

    //需要注意的是：在字面量表示中，始终会共享一个实例，但是构造函数创建的则每次都不同。
            for(i=0;i<10;i++){
                part=/cat/g;
                part.test("catastrophe");           //这里循环一次之后，第二次调用时无法找到cat，因为第二次会从3的位置开始查找
                        }                               //

            for(i=0;i<10;i++){
                part=new RegExp("cat","g");
                part.test("catastrophe");           //构造函数创建的每个实例都不同，每次都会返回true。
            }

    //RegExp 实例方法：

//       1.exec():专门为捕获组设计的方法
//        语法：
            var matches=pattern.exec(text);  //text 是要匹配的文本  pattern是正则表达式

        //返回一个数组matches[]，外加两个属性index，input
            alert(matches.index);           //匹配项在文本中的位置
            alert(matches.input);           //文本内容
            alert(matches[0]);              //数组中第一项是匹配整个表达式的字符串
            alert(matches[1]);               //第二项是匹配第一个捕获组的内容，如果第一个捕获组没有内容，则为undefined，空项
            alert(matches[2]);               //第二项是匹配第二个捕获组的内容，如果第一捕获组没有内容，还是会放在该项中


        //exec()方法每次只能获取一个匹配对象，当字符串中有很多个匹配对象时，需要设置pattern的标识为全局模式，每执行一次匹配，返回下一个匹配项，通过这种方法，我们能获得字符串中所有的匹配项，所有的捕获组，但是为了避免重复匹配（全部匹配完后又会从开头重新匹配），需要加入一个判断，while(matches),当获取所有的匹配项后，检查不到匹配时，matches值为null，循环结束，退出。

        //什么是捕获组？看一个正则表达式：
            var pattern=/mom(and dad(and baby)?)?/gi;//从左到右，第一个“(”后面的是第一个捕获组，第二个“(”后面的是第二个捕获组。

//       2.test() 如果有匹配的则返回true，没有则为false，常用于if语句中判断
            if(pattern.test(text)){
                alert("The pattren was matched");
            }

//      3.toString() toLocaleString() 方法，始终返回正则表达式的字面量表示 。还有一个pattern.source属性也是返回字面量表示。


    //RgeExp 构造函数属性

        //调用构造函数属性获取的值都是构造函数最近一次匹配的字符串中的值

            var text="this has been a short summer";
            var pattern=/(.)hor(.)/g;
            if(pattren.test(text)){
            alert(RegExp.input);                    //最近一次匹配的文本             RegExp.$_
            alert(RegExp.lastMatch);                  //最近一次匹配的字符串
            alert(RegExp.leftContext);                //最近一次匹配字符串之前的文本
            alert(RegExp.rightContext);               //最近一次匹配字符串之后的文本
            alert(RegExp.lastParen);                   //最后一个匹配的捕获组
            alert(RegExp.$1);                          //$1-$9分别表示第一到第九个捕获组，最后一个就是lastParen
        }


//******************************Function 类型

    //定义函数的2中方法：
        //函数声明：
            //特别注意函数声明提升的问题。
            function sum(num1, num2) {                   //执行js中代码前已经就绪可用
                return num1 + num2;
            }
        //函数表达式：

            var sum = function (num1, num2) {           //函数执行到它所在的代码位置时被解析，也就是说，调用函数要在这个语句之后。否则无法
                                                        //被调用。
                return num1 + num2*2;
            };

            alert(sum(10,10));                          //30   函数没有重载，前面的sum指针被后面的覆盖了

        //函数名其实是一个指向函数的指针，不会与某个函数绑定

            var anotherSum=sum;                 //把sum赋值给anotherSum,复制了一个指针。注意：sum没有()表示访问指针，不是调用函数
            alert(anotherSum(10,10)) ;                   //30

        //函数可用用作另一个函数的参数，也可以被另一个函数所返回(闭包形式)


        //函数内部2个对象 argument对象也就是参数对象，可以使用argument[n]来访问各个参数，还有一个就是this对象，代表的是调用该
        //      函数的对象，argument还有一个callee的属性，指向argument所在的函数。

            function factoral(num) {                        //阶乘函数
                if(num<=1) {
                    return 1;
                }
                else{
                    //return num*factoral(num-1);             //弊端：如果想把函数复制给其他变量不可能，因为函数中的factoral绑定了该
                                    //                         函数名。 var  anotherFactoral=factoral;      // 无法实现

                    return num*arguments.callee(num-1);     //arguments.callee代表的就是factoral函数 ，这样就可以实现将函数复制
                                                            //给其他变量了。
                }
            }

        //函数的caller属性，保存调用当前函数的函数的引用，如果调用当前函数的是全局作用域，则它的值为null。

        //函数的属性和方法：
            //length属性：function.length表示函数参数的个数。

            //prototype属性：该属性无法枚举 无法使用for-in来发现，在后面重点介绍。

            //2个非继承而来的方法：call()  apply()    强大之处在于可以扩充函数的作用域 当函数被调用时，创建了一个自己的执行环境如                      call(obj,...)那么调用call的函数中的this对象就是obj。
            //

                function sum(a,b) {
                    return a+b;
                }

                function callsum(num1,num2) {
                    return sum.call(this,num1,num2);            //call()中参数时逐个列举的
                    return sum.apply(this,[num1,num2]);         //apply()中参数可以是array的实例或者arguments对象
                    return sum.apply(this,arguments)
                }
                alert(callsum(1,2));

            //bind()方法
                var o={color:"blue"};
                function sayColor() {
                    alert(this.color);
                }
                var objectSayColor=sayColor.bind(o);
                //函数调用了bind方法并绑定了o，同时创建了一个objectSayColor函数，无论在哪里调用objectSayColor函数，this值始终
                //绑定在o上，也就是说，this.color始终是blue。


//**********************************基本包装类型

    //三个特殊的引用类型：Boolean,String Number

        //Boolean类型:区别于Boolean基本类型，typeof返回object  instanceof Boolean返回true，进行逻辑操作（与 或 非）始终为true

        //Number类型：
            var numberObject=new Number(10);
            alert(numberObject.toFixed(2));         //10.00  toFixed方法表示几位小数。适合处理货币问题

            var num=10.005;
            alert(num.toFixed(2));                  //10.01 后面的数字会自动舍入。

            //toExponential()方法     返回指数表示 ，一个参数 代表的是小数的位数
            var num1=193;
            alert(num1.toExponential(1));       //1.9e+2

            //toPrecision()方法       返回toFixed()方法返回的值或者toExponential()方法返回的值。一个参数，表示数字的位数（不是小数的位数）

        //String类型：


            //字符方法：
                var stringValue="hello world";
                alert(stringValue.charAt(1));           //e  返回指定位置的单个字符串  stringValue[1] 效果相同
                alert(stringValue.charCodeAt(1));       //101     返回指定位置字符串的编码

            //slice() substr() subString()方法：   返回一个操作后的子字符串，如果没有第二个参数，则默认到字符串结尾为结束位置。

              //slice()同数组中的slice()方法
                 alert(stringValue.slice(3));           //lo world
                 alert(stringValue.slice(3,7));      //lo w

              //subString()方法 ：参数为负数时全部转化为0，其中参数为正数时，其效果和slice()相同。

              //substr()方法：第一个参数为开始位置 ，第二个参数为获取的字符串的长度。 第一个参数负数时加字符串长度，第二个参数为负数时 返回空字符串

            //位置方法类同数组

            //trim()方法：删除数组中前置和后缀中所有的空格，返回一个副本，原来的数组不变。


            //大小写转化方法：toUpperCase()和toLowerCase()  把字符串大写或者小写

            //字符串的匹配模式方法：

                //match()方法：类似于RgeExp的exec()方法。
                    var text="cat,bat,sat,fat";
                    var pattern=/(.)at/g;               //这里设置了全局标志
                    var matchess=text.match(pattren);
                    alert(matchess.index);              //设置了全局标志就会返回undefined？为什么？
                    alert(matchess[0]);                 //cat
                    alert(matchess[1]);                 //bat
                    alert(matchess[2]);                 //sat   这里全局匹配 获得所有匹配项存在数组中 而不是exec()中的捕获组
                    var match=pattern.exec(text);
                    alert(match.index);                 //0     匹配项在文本中的位置
                    alert(match[0]);                    //cat  第一个匹配项
                    alert(match[1]);                    //c   第一个捕获组
                    alert(match[2]);                    //undefined     没有第二个捕获组了
                    //如果再执行一次exec操作后，全局匹配情况下，match.index match[0] match[1]都会是后一个匹配项的信息

                //search()方法：类似于indexOf()方法。indexOf中参数时字符串，而search中是一个正则表达式，二者都是返回第一个匹配项
                            //  的位置，如果没有则返回-1。不同的是，indexOf中可以指定开始搜索的位置，而search中始终都是从头开始。
                    var pos=text.search(/at/);
                    alert(pos);          //1

                //replace()方法：2个参数，第一个参数是字符串或者正则表达式，第二个参数是字符串或者函数。返回被替换后的函数。

                    var result=text.replace("at","ond");
                    alert(result);          //cond,bat,sat,fat  第一个参数是字符串，只替换第一个匹配项

                    var result2=text.replace(/at/g,"ond");
                    alert(result2);         //cond,bond,sond,fond  第二个参数是正则表达式，且需设置全局标志g

                    //如果第二个参数是字符串，还可以使用特殊的字符$&(整个匹配的字符串),$n(表示第几个捕获组)

                    var result3=text.replace(/(.at)/g,"word($1)");

                    //既然全局状态下，match()只能获得匹配项，无法获得捕获组，而exec()一次只能匹配一个，需要循环才能获得所有捕获组，
                    // 如何获得所有捕获组?
                    var text="cat,bat,sat,fat";
                    var result4=text.replace(/(.at)/g,function (match,$1,index,original) {
                        //有捕获组的情况下，参数传递的顺序：匹配项，捕获组1，捕获组2....，匹配项在字符串中的位置，原始字符串
                        //match是匹配项，全局状态下就是所有匹配的项组成的字符串。所有匹配项并不是同时传入函数中，所以在函数
                        //内可以对每个匹配项进行判断。
                        switch (match){
                            case "cat":return 1;
                            ......

                        }
                        //$1是第一个捕获组（这里只有一个，如果有2个，那后面应该还有$2）
                        //
                    })


                 //split()方法：
                        //基于一个指定的字符 将字符串分割成数组，和join()方法是相反的。

            //localCompare()方法:

                  //比较2个字符串，如果字符串在字母表中应该在字符串参数之前，返回一个负数。比如，对一个数组中的所有字符串进行
                //   按字母表排序
                //假定字符串中有多个字符，且不分大小写，先要按照字母表的顺序将他们排序。
                    array=string.split(",");
                    array.sort(function (a,b) {
                        return a.localeCompare(b);      //a在b之前 返回一个负数
                    });

        //Math对象:

            //min()方法和max()方法：用于确定一组数中的最大值和最小值
                var max=Math.max(3,54,32,16);
                var min=Math.min(3,54,32,16);

                //如果这组数是一个数组，不是单个的数值呢，可以使用apply()对该方法传参。

                var values=[1,2,3,4,5,6];
                var max1=Math.max.apply(Math,values);

            //Math.ceil():向上舍入  舍入为最近的整数
            //Math.floor():向下舍入
            //Math.round():标准舍入

            //值=Math.floor(Math.random()*数的总个数+第一个值)；
            //更直观一些：
                function selectFrom(value1,value2) {
                    var number=value2-value1+1;                     //数的总个数

                    return Math.floor(Math.random()*number+value1);
                }
                var num=selectFrom(2,10);
                alert(num);             //   介于2和10之间的数。



//******************************    第六章  面向对象程序设计 ************************************************

    //属性类型：
        //每个对象中的属性，还有其内部的特性，也就是属性中的特性（2个方括号表示）
        //属性中的数据属性的4个特性：

            //  [[Configurable]]   :能否通过delete删除属性从而重新定义属性 默认true  如delete aqiData[cityStr]; 就删除了aqiData对象中的
                //cityStr属性 ， Configurable 特性被修改为false之后，其他特性都不能再被修改，除了Writable可以从true修改为false

            //  [[Enumerable]]  :  能否通过for-in循环属性。for (cityStr in aqiData) ， 默认true

            //  [[Writable]]    :   能否修改属性的值   ， 默认true

            //    [[Value]]      :  包含属性的数据值  ， 默认是undefined

            //修改数据属性中特性的默认值，可以使用Object.defineProperty()方法：三个参数，属性所在的对象，属性的名字，以及一个描述符对象。
            //  如果用该方法创建的属性，其4个特性全都是false，在描述符对象中，你可以对数据属性中的特性进行修改 例如：

                var person={};
                Object.defineProperty(person,"name",{   //name属性要加引号
                    value:"fuzhengsong",       //把name属性的值修改成了fuzhengsong
                    writable:false              //无法修改name属性的值,如果属性在外部定义情况下，通过内部还是可以修改name的值。

                });
                alert(person.name);         //fuzhengsong
                person.name="Grge";
                alert(person.name);         //fuzhengsong

        //属性中的访问器属性：没有数据值，有一对函数：getter()和setter()  当设置一个属性导致另一个属性发生变化时，可以使用这种方法。
                var book={
                    _year:2004,
                    edition:1
                };
                Object.defineProperty(book,"year",{
                    get:function () {
                        return this._year;

                    },
                    set:function (newValue) {
                        if(newValue>2004){
                            this._year=newValue;
                            this.edition+=newValue-2004;
                        }
                    }
                });


    //定义多个属性：Object.definePorperties()。将上述的数据属性和访问器属性放在同一个对象之中。

    //读取属性的特性：Object.getOwnPropertyDescriptor()方法，2个参数：属性所在的对象，属性名


    //创建对象：
        //1.工厂模式：使用一个函数来创建，函数参数为要传入的属性值，函数内部定义好对象和属性以及属性值后返回一个对象即可。
                //弊端：每个创建的对象都是相同的对象类型

        //2.构造函数模式：使用一个构造函数来创建

            function  Person(name,age,job) {
                this.name=name;
                this.age=age;
                this.job=job;
                this.sayName=function () {
                    alert(this.name);
                }
            }
            var person1=new Person("niko","28","Doctor");   //这里可以指定不同的对象类型,既是Person实例也是Object实例

            //弊端：每次调用函数创建一个对象都会创建一个不同的sayName()对象(函数也是对象)。

        //3.原型对象：

                function Person() {
                    Person.prototype.name="niko";
                    Person.prototype.age="29";
                    Person.prototype.job="Doctor";
                    Person.prototype.sayName=function () {
                        return this.name;
                    }
                }

            //第一个概念：我们创建了一个函数，这个函数有个属性叫Prototype,它指向这个函数的原型对象。Function.Prototype=原型对象
                //原型对象又会自动获取一个属性，叫constructor，指向Prototype所在的函数，Function.Prototype.constructor=Function

            //构造函数和原型对象确定了，然后创建一个实例，实例中也有一个指针[[Prototype]]指向原型对象。
            //getPrototypeOf()方法可以获取某个实例的原型对象。
            alert(Object.getPrototypeOf(person1)==Person.prototype);

            //第二个概念：当我们要获取一个实例的属性的时候，首先，会判断在实例本身中有没有定义这个属性，如果没有，那就向上寻找原型
                // 如果原型中有，那么返回原型中的属性。实例本身中的属性会覆盖原型中的属性。

            //可以使用hasOwnPropertype()属性来判断一个实例本身是否拥有这个属性。
            alert(person1.hasOwnProperty("name"));

            //in操作符：判断一个属性是否在实例或者原型中
            alert("name" in Person1);//true

            //for-in循环：返回所有能够访问的、可枚举的属性 无论在实例中还是原型中。
            for(attribute in Object)
            //不可枚举的属性方法：hasOwnProperty(),properIsEnumerable(),toLocalString(),toString(),valueOf()。

            Object.keys(person1)
            //返回可枚举的实例属性，不包括原型内

            Object.getOwnPropertyNames(person1);
            //返回实例属性中的可枚举的或者不可枚举的属性，不包括原型。

        //更简单的原型语法：
            function Person(){

            }
            Person.prototype={                      //将原型属性和方法放在了一个原型对象中，相当于重写了原型对象，所以一个不同点就是
                                                    //  其constructor指向了Object而不是Person了。
                constructor:Person,                 //重新指定其constructor属性。但是这种情况下设置的constructor是可以枚举的。正常情况                                           下是不可枚举的。
                name:"niko",
                age:"29",
                job:"Doctor",
                sayName:function () {
                    return name;

                }
            };
            //使用defineProperty()方法，添加属性同时修改其特性
            Object.defineProperty(Person.prototype,"constructor",{
                value:Person,
                Enumerable:false

            });
        //原型对象中的问题：
            function Person(){

            }
            Person.prototype={
                name:"niko",
                age:"29",
                job:"Doctor",
                sayName:function () {
                    return this.name;
                },
                friend:["curry","james"]                //原型中定义了一个数组的属性
            };
            //当所有的实例都指向了原型，原型内部的属性都是共享的，当一个实例改变了原型内部的引用类型的值，在另一个实例中也会体现出来
            var person1=new Person;
            var person2=new Person;
            person1.friend.push("jack");
            alert(person1.friend);       //curry,james,jack
            alert(person2.friend);       //curry,james,jack

        //构造函数和原型模式结合方式：
            //每个对象都要拥有自己不同的实例属性，那该属性就申明在构造函数中，如果所有实例共有的属性就申明在原型中。
            function People() {
                this.name=name;
                this.age=age;
                this.job=job;
                this.friend=["curry","james"];
            }
            People.prototype={
                sayName:function () {
                    return this.name;
                }
            }

        //动态原型模式：用来封装原型和构造函数
            function Person(name, age, job) {
                this.name = name;
                this.age = age;
                this.job = job;
                if (typeof this.sayName != "function") {
                    Person.prototype.sayName = function() {     //这里面可以定义很多个原型方法 只要判断其中一个就可以。
                        alert(this.name);
                    };
                }
            }
        /*Person是一个构造函数，通过new Person(...)来生成实例对象。每当一个Person的对象生成时，Person内部的代码都会被调用一次。

        如果去掉if的话，你每new一次(即每当一个实例对象生产时)，都会重新定义一个新的函数，然后挂到Person.prototype.sayName属性上。而实际上，你只需要定义一次就够了，因为所有实例都会共享此属性的。所以如果去掉if的话，会造成没必要的时间和空间浪费；而加上if后，只在new第一个实例时才会定义sayName方法，之后就不会了。

      假设除了sayName方法外，你还定义了很多其他方法，比如sayBye、cry、smile等等。此时你只需要把它们都放到对sayName判断的if块里面就可以了。
      这样一来，要么它们全都还没有定义(new第一个实例时)，要么已经全都定义了(new其他实例后)，即它们的存在性是一致的，用同一个判断就可以了，而不需要分别对它们进行判断。*/

     //继承

        //原型链
            function SuperType() {
                this.name=true;
            }
            SuperType.prototype.getSuperValue=function () {
                return this.name;
            };
            function SubType() {
                this.SubName=false;
            }

            SubType.prototype=new SuperType;
            SubType.prototype.getSubName=function () {  //在原型被实例化后定义 不然会被覆盖。也不能使用字面量法，会重写上面的原型
                return this.SubName;
            };
            var instance=new SubType();
            alert(instance.name);                   //true
            alert(instance.getSubName());           //false
            alert(instance.getSuperValue());        //true

        //在原型链中，把一个函数的原型对象作为另一个构造函数的实例，这样一来，后面的定义的实例就可以使用原型链中之前的原型对象的属性和
            //方法，原型链很强大，它不需要后面的原型对象再重新定义方法或者属性，直接继承之前的就可以。但这也带来了一个类似于原型模式
            //中的问题，因为原型链后一个原型对象会将之前原型对象的实例属性变成自己的原型属性，这样一来，之前定义的实例属性(在构造函数中的)
            //就变成了共享的属性。

        //借用构造函数：
        //每次创建一个subType()的实例时，都会调用superType函数，并且可以使用call传入参数到superType，这样一来，每个subType()的实例
        //都会有一个独立的color属性，互不影响。拥有了这个功能，我们可以应用到原生链中去。
            function superType() {
                this.color=["red","blue","green"];
            }
            function subType() {
                superType.call(this);
            }
            var instance1=new subType();
            instance1.color.push("black");      //red blue green black
            var instance2=new subType();
            alert(instance2.color);             //red blue green

        //借用构造函数和原型链组合的模式：


            function superColor(name) {                         //superColor构造函数
                this.color=["red","blue","green"];
                this.name=name;
            }
            superColor.prototype.sayName=function () {          //定义superColor原型方法
                alert(this.name);

            };
            function subColor(name,age) {                       //subColor构造函数                          第二次调用
                 superColor.call(this,name);    //传递参数
                this.age=age;
            }
            subColor.prototype=new superColor();                //把subColor原型作为supColor的实例，继承了实例属性和原型属性                                                                         第一次调用
            subColor.prototype.constructor=subColor;            //subColor.prototype的constructor原本指向的是superColor
            subColor.prototype.sayAge=function () {             //定义subColor的原型方法
                alert(this.age);
            };
            var instance4=new subColor("niko","29");            //2个实例，拥有自己不同的实例属性。
            instance4.color.push("black");
            alert(instance4.color);
            instance4.sayName();
            var instance5=new subColor("nikolas","30");
            instance5.color.push("brown");
            alert(instance5.color);
            instance5.sayName();

            //组合模式也有存在的问题：需要调用2次superColor构造函数。而且继承的实例属性也会存在于后面对象原型之中(只是第二次调用时创建的
//              实例属性将原型中的覆盖屏蔽了)，造成了空间的浪费。试想：可不可以只继承原型共享的方法，而不继承实例属性，实例属性通过调用
                //构造函数的方法实现？

        //原型式继承：
            function object(o) {
                function F() {

                }
                F.prototype=o;
                return new F();
            }
            //ES5中规范了这个函数：Object.creat():2个参数。第一个：用作新对象原型的对象(o),第二个:为新对象额外定义的属性，类似
                //Object.defineProperties()的方法。

            var person={
                name:"nikolas",
                friends:["niko","james"]
            };
            var anotherPerson=Object.create(person,{        //person对象 就是anotherPerson的原型
                name:{
                    value:"greg",
                    Writable:false
                }
            });
            //如果person只是一个原型对象，不包括实例属性呢?而anotherPerson作为一个以person为原型对象的构造函数的实例，如果赋值给
                //另一个对象的原型，那就构成了只继承原型对象的原型链。

        //寄生组合式继承：
            //把superColor的原型对象继承给了subColor的原型对象。
            function  inherit(subColor,superColor) {
                subColor.prototype=Object.create(superColor.prototype);
                subColor.prototype.constructor=subColor;
            }

            function superColor(name) {                         //superColor构造函数
                this.color=["red","blue","green"];
                this.name=name;
            }
            superColor.prototype.sayName=function () {          //定义superColor原型方法
                alert(this.name);

            };
            function subColor(name,age) {                       //subColor构造函数

                superColor.call(this,name);    //传递参数
                this.age=age;
            }
            inherit(subColor,superColor);
            subColor.prototype.sayAge=function () {             //定义subColor的原型方法
                alert(this.age);
            };


 //*************************************************函数表达式*********************************************************

        //函数声明：
            function myfunction() {
                //函数体
            }
        //函数表达式：也称匿名函数，经常用来作为闭包。
            var myfunction=function () {

            }

        //递归函数：
            var factorial= ( function F(num) {     //function F()是一个函数表达式，F名字仍然有效 但是typeOf F是undefined，不是函数
                if(num<=1){
                    return 1;
                }else {
                    return num * F(num - 1);
                }
            });

                var number=factorial(4);         //24

        //闭包：有权访问其他函数内变量的函数。
            


//*************************************************BOM*********************************************************8
    //window对象：
        //所有在全局作用域中声明的变量和函数都会变成window对象的属性和方法。
        //全局变量不能通过delete的方式删除，但是直接在window对象上定义的属性就可以。
            var age=29;
            window.color="red";
            delete window.color;        //可以
            delete window.age;      //不可以

        //窗口关系和框架：
            //top对象：指向最外层的框架，也就是浏览器窗口。
            top.frames["framename"]     //可以用来访问框架名为framename的框架。不用window.frames的原因：window是指向当前框架的，而不是                                          指向最高层的框架，所以有时候不能很正确的访问另一个框架

            //parent对象：指向当前框架的直接上层
            if (window.parent != window.top) {
                // 至少有三层窗口
            }

        //窗口位置：
            //IE Safari Opera Chrome提供：screenLeft  screenTop

            //FireFox提供：screenX screenY (Chrome和Safari也支持这两个属性)。

            //IE Opera中screenLeft  screenTop的值得判定：top是浏览器窗口相对屏幕的值还要加上工具栏的像素高度。

            //Chrome FireFox Safari 中的‘screenLeft  screenTop’或者‘screenX screenY’值得判定：浏览器窗口相对屏幕的值。

            //screenLeft属性是否可用？可用就返回该值 不可用就返回window.screenX，用于区分FireFox.
                var leftPos=(typeof window.screenLeft=="number")?window.screenLeft:window.screenX;
                var topPos=(typeof window.screenTop=="number")?window.screenTop:window.screenY;

            //对于最外层的window对象，可用使用moveto()和moveby()方法对窗口进行移动。

                window.moveTo(0,0);         //移动到左上角
                window.moveBy(0,100);       //向下移动100px


        //窗口的大小：
            //IE9+,FireFox，Chrome，Safari，Opera四个属性：innerWidth innerHeight outerWidth OuterHeight，两个inner属性表示视图区的                大小，两个outer表示浏览器窗口本身的大小。
            //需要注意的是：在Chrome中这inner和outer的值是相同的。

            //IE8之前的版本中，没有这些属性，只有通过DOM来访问。

                var pageWidth=window.innerWidth;
                var pageHeight=window.innerHeight;
                if(typeof pageWidth!="number"){
                    if(document.compatMode=="CSS1Compat"){                  //判断是否是标准模式
                        pageWidth=document.documentElement.clientWidth;
                        pageHeight=document.documentElement.clientHeight;
                    }else{
                        pageWidth=document.body.clientWidth;            //混杂模式
                        pageHeight=document.body.clientHeight;
                    }

                }

            //调整浏览器窗口的大小:
                window.resizeTo(100,100); //设置窗口大小为100*100
                window.resizeBy(200,100); //在原来基础上宽度加200 高度加100 变成 300*200

        //导航和打开窗口：

            //弹出窗口：
               var newWindow= window.open("http://www.wrox.com","_blank","height=400,width=400,top=20,left=20,resizable=yes");
                //返回一个指向新窗口的引用
               newWindow.resizeTo(500,500);
               alert( newWindow.opener==window); //true opener指向打开它的原始窗口的对象。
               newWindow.opener=null;            //切断于原始窗口的关系 无法恢复。
               newWindow.close();               //可以关闭弹出的窗口

                //window.open的四个参数：URl地址，窗口目标，特性字符串，表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。
                //窗口目标：
                    /*  _blank:新窗口
                    *   _self:当前窗口
                    *   _top:清除所有被包含的框架并将文档载入整个浏览器窗口
                    *   _parent:文档载入父窗口或者包含来超链接引用的框架的框架集
                    *   也可以是自己命名的框架或窗口*/
                //特性字符串：用来设置新窗口的一些属性

            //出于安全性的考虑，现在很多浏览器都有浏览器屏蔽程序，如何判断是否被屏蔽？
                var newWindow= window.open("http://www.wrox.com","_blank","height=400,width=400,top=20,left=20,resizable=yes");
                if(newWindow==null){
                    alert("窗口被屏蔽了！");
                }

            //如果不是内置的屏蔽程序屏蔽而是扩展程序屏蔽 ，会抛出一个错误，就需要用到try-catch语句：
                try{
                    var newWindow= window.open("http://www.wrox.com","_blank","height=400,width=400,top=20,left=20,resizable=yes");
                    if(newWindow==null)
                        alert("窗口被屏蔽！")
                    }
                    catch(ex) {
                        alert("窗口被屏蔽！")
                    }
        //间歇调用和超时调用
            //超时调用：
                var timeOut=setTimeout(function () {    //返回一个数字ID，唯一标识符
                    alert("Hello")
                },1000);
                clearTimeout(timeOut);          //取消超时调用
            //间歇调用：
                inertvalId=setInterval("执行的代码或者函数",1000);
                clearInterval(inertvalId);
                //尽量使用超时调用来取代间歇调用。

        //系统对话框：
            //alert()

            //confirm()     返回一个布尔值 用户确定为true 取消为false
                if(confirm("Aer you sure?")){

                }
                else{

                }
            //prompt()  参数：给用户的文本提示以及文本域的默认输入内容  返回用户输入的内容
                var result=prompt("What?","");
                if(result!=null){

                }


    //location对象：
        //查询字符串参数：解析url中的查询字符串，将其中的所有参数放入一个对象中。
            function  getQueryStringArgs() {
                    //储存所有参数以及值
                var arg={};

                //取得查询字符串并删去开头的‘?’
                var qsStr=(location.search.length>0)?location.search.subtring(1):"";
                //将字符串以&为断点分割开来
                var arg1=qsStr.split("&");
                for(var i=0;i<arg1.length;i++){
                    //取得arg1 数组中的每一项，并以等号为断点分割
                    var arg2=arg1[i].split("=");
                    var argName=decodeURIComponent(arg2[0]); //查询字符串被编码过 ，所以用这个方法解码。
                    var argValue=decodeURIComponent(arg2[1]);
                    arg[argName]=argValue;

                }
                return arg;
            }
        //位置操作：
            //使当前网页跳转到指定页面 还有location.hash,search,hostname,pathname,port
            location.href="http://www.baidu.com";
            location.assign("http://www.baidu.com");
            //使用replace之后无法回退到之前的页面。
            location.replace("http://www.baidu.com");
            //reload()方法 参数为true则从服务器重新加载，不指定就从缓存中加载
            location.reload(true);


    //navigator对象

        //检测插件：
            //plugins数组中，每一项都有四个属性：
                /*name：插件名字
                * description：插件描述
                * filename：插件文件名
                * length：*/
            //对于非ie浏览器，可以使用plugins数组检测：
                function hasPlugin(name) {
                    //把要检测的插件名字小写，便于检测
                    name=name.toLowerCase();
                    //遍历plugins数组中的所有项
                    for (var i=0;i<navigator.plugins.length;i++){
                        //plugins数组中的插件名字也要小写
                        if(navigator.plugins[i].toLowerCase().indexOf(name)>-1){
                            return true
                        }
                    }
                }
                alert(hasPlugin("Falsh"));

            //在IE中如何检测？
                function hasIEPlugins(name) {           //这里的name参数是插件名对应的DOM表示符
                    try{
                        new ActiveXObject(name);
                        return true
                    }
                    catch (ex){
                        return false;
                    }
                }
                alert(hasIEPlugins("ShockwaveFlash.ShockwaveFlash"));

         //screen对象

        //history对象
            //history对象不常用，但是如果要自定义前进后退按钮，或者判断是否是第一个页面时有用。

            //go()方法可以使页面前进或者后退
            history.go(1);      //前进一页
            history.go(-1);     //后退一页
            history.go("wrox.com"); //跳转到最近访问过在历史记录中最近的符合的网页
            if(history.length==0){
                //第一个页面
            }


//****************************************************   JSON*****************************************************
        //JSON语法可以表示三种类型的值：/*简单值：字符串、数组、布尔值和null，字符串必须使用双引号，不支持undefined
//                                      对象：键值对
//                                      数组*/
        //不支持：变量，函数，实例对象

        //对象：js中的对象属性不需要加引号，但是在JSON中必须要加引号才能不导致错误
        //js中:
        var object={
                name:"Nicholas",
                age:"29"
        };

        //JSON中：
        {                    //没有声明变量
            "name":"Nicholas",
            "age":29
        }                   //JSON中没有分号


        //JSON对象的2个方法：stringify()和Parse()

            //stringify()把js对象序列化为JSON字符串：三个参数 需要转化的js对象，过滤器，缩进参数
            var book={
                title:"Professional JavaScript",
                authors:["Nicholas C.Zakas"],
                edition:3,
                year:2011
            };
            //@param {[type]}  数组
            var jsonText=JSON.stringify(book,["title","edition"]);  //json字符串中只有title和edition属性

            //第二个参数为函数：函数内2个参数 属性名和属性值
            jsonText=JSON.stringify(book,function (key,value) {
                switch (key){
                    case "authors":return value.join(",");
                    case "year": return 5000;
                    case "edition":return undefined;        //返回undefined会删除该属性
                    default:return value;                   //需要提供default，这样其他的属性才能被返回
                }
            });

            jsonText=JSON.stringify(book,null,4);           //转换成的字符串会换行且缩进4个空格,不能超过10个空格
            jsonText=JSON.stringify(book,null,"--");        //转换成字符串会换行，且缩进字符为“--”符号，也不能超过10个

            //对象中的toJSON方法：

            var contact = new Object();
            contact.firstname = "Jesper";
            contact.surname = "Aaberg";
            contact.phone = ["555-0100", "555-0120"];
            contact.toJSON = function(key)  {
                var replacement = new Object();                     //toJSON方法中定义了一个新对象
                for (var val in this){
                    if (typeof (this[val]) === "string")
                    replacement[val] = this[val].toUpperCase();

                else
                    replacement[val] = this[val];
                }
                return replacement;                                 //返回一个新的对象，最后序列化为字符串的就是这个对象

            };
            jsonText = JSON.stringify(contact);     //首先调用对象中的toJSON方法，是不是有返回值，如果有将其返回值进行转化，如果没有则转化对象本身--这里就是contact,这里返回了replacement,那么就对replacement对象进行stringify()，当toJSON返回了undefined，如果该对象在其他对象中，那它的值就是null，如果是顶级对象中结果就是undefined了。


                    /* The value of jsonText is:
         ‘{"firstname":"JESPER","surname":"AABERG","phone":["555-0100","555-0120"]}‘ */


          //JSON.parse()方法也可以接受一个函数，还原json字符串

//**************************************************Ajax Comet**************************************************************

        //XMLHttpRequest()对象
        var xhr=createXHR();

        //xhr的用法：

        //open()方法，启动一个请求以备发送。
        xhr.open("get","example.php",false);        //参数：要发送的请求类型get/post,请求的URL和是否异步发送请求的布尔值。

        //要发送请求，需要调用send()方法：
        xhr.send(null);     //不需要发送主体是设置为null
        /*readyState的状态：
         * 0：未初始化，未调用open()方法
         * 1:启动。已经调用open(),尚未调用send()
         * 2:发送。已经调用send()方法
         * 3:接受。已经接受到部分响应数据
         * 4：完成。已经接受到全部的响应数据*/
        xhr.onreadystatechange=function () {        //使用Dom0级方法创建监听事件

            if(xhr.readyState==4){                  //没有使用event,而是使用了xhr事件本身
                //status==200为成功的标志，304表示请求的资源没有被修改
                if((xhr.status>=200&&xhr.status<=300)||xhr.status==304){
                    alert(xhr.responseText);
                }
                else{
                    alert("Request was unsuccessful"+xhr.status);
                }
            }
        };

        xhr.open("get","example.php",false);
        xhr.send(null);
        //在接受到响应之前，可以使用abort()方法来取消异步请求，不会再出发onreadystatechange事件
        xhr.abort();

        //HTTP头部信息：
            //2种操作头部的方法：
            //setRequestHeader方法需在open()方法之后，send()方法之前
            xhr.setRequestHeader("MyHeader","MyValue");//参数：头部字段名和头部字段值

            var myHeader=xhr.getResponseHeader("MyHeader");     //取得响应的头部
            var allHeader=xhr.getAllResponseHeaders();          //取得所有的头部

        //Get请求：常用于向服务器查询信息，可以将需要查询的字符串添加到URL末尾

        function  addURLParam(url,name,value) {
           url+=url.indexOf("?")==-1?"&":"?";
           url+=encodeURIComponent(name)+"="+encodeURIComponent(value);
           return url;
        }

        //POST请求：向服务器发送被保存的数据。
        xhr.open("post","postexample.php",true);
        xhr.send(serialize(form));

        //XMLHttpRequest2级：
            //FormData类型：表单数据的序列化
                var data=new FormData(document.Forms[0]);

            //超时设定：
            xhr.timeout=1000;
            xhr.ontimeout=function () {
                alert("Request did not return in a second.")
            };

            //overrideMimeType()方法：设定把响应当做什么MIME的类型处理，必须在send之前设定

            xhr.overrideMimeType("text/xml");
            xhr.send(null);


            //进度事件:
            var XHR=createXHR();

            //可以替代onreadystatuschange
            XHR.onload=function (event) {
                if (XHR.status >= 200 && XHR.status <= 300 || XHR.status == 304) {
                    alert(XHR.responseText);
                } else {
                    alert("Request was unsuccessfun" + xhr.status);
                }
            };
            //周期性触发progess事件，三个额外的属性：lengthComputable进度信息是否可用，position已经接受的字节数，totalSize预期字节总数。
            XHR.onprogess=function (event) {
                var divStatus=document.getElementById("status");
                if(event.lengthComputable){
                    divStatus.innerHTML="Received"+event.position+"of"+event.tatalSize+"bytes.";
                }
            }



    </script>
</head>
<body>

</body>
</html>